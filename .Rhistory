print(di)
}
}
for(di in c(3:length(d)) ){
if(d[di] < mean(d[c( (di-2):di )])){
print(di+1)
}
}
for(di in c(6:length(d)) ){
if(d[di] < mean(d[c( (di-5):di )])){
print(di+1)
}
}
# sharp decrease in dev
d <- diff(res_df$dev)
for(di in c(4:length(d)) ){
if(d[di] < 2*mean(d[c( (di-3):di )])){
print(di+1)
}
}
diff(res_df$dev)
# sharp decrease in dev
d <- diff(res_df$dev)
for(di in c(4:length(d)) ){
if(d[di] < 3*mean(d[c( (di-3):di )])){
print(di+1)
}
}
# sharp decrease in dev
d <- diff(res_df$dev)
for(di in c(4:length(d)) ){
if(d[di] < 3*mean(d[c( (di-3):di )]) & mean(d[c( (di-3):di )])<0 ){
print(di)
}
}
di=15
mean(d[c( (di-3):di )])
d[c( (di-3):di )]
mean(d[c( (di-3):(di-1) )])
# sharp decrease in dev
d <- diff(res_df$dev)
for(di in c(4:length(d)) ){
if(d[di] < 3*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<0 ){
print(di)
}
}
d
di=19
mean(d[c( (di-3):(di-1) )])
# sharp decrease in dev
d <- diff(res_df$dev)
for(di in c(4:length(d)) ){
if(d[di] < 10*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<0 ){
print(di)
}
}
di=19
10*mean(d[c( (di-3):(di-1) )])
d[di]
plot(diff(d))
plot(d)
# sharp decrease in dev
d <- diff(res_df$dev)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
plot(diff(d))
res_df$dev
d
ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = sim_condition$n_ttl_betas, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
plot(dev)
plot(res_df$devdev)
plot(res_df$dev)
par(mfrow=c(2,1))
plot(d)
plot(res_df$dev)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 10*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<0 ){
print(di)
}
}
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 10*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(di)
}
}
par(mfrow=c(2,1))
plot(d)
plot(res_df$dev)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 10*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(di)
}
}
par(mfrow=c(2,1))
plot(d)
plot(res_df$dev)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(paste0("big jump at ",di))
}
}
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(paste0("big jump at model size",di))
}
}
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(paste0("sharp decrease in dev at model size",di))
mal <- T
}
}
# loodev best should not be too far away from data generating model
e <- abs(best_df$best_size[best_df$score=="loodev"] - sim_condition$n_ttl_betas)
if(e >  max(res_df$model_size)/5){
print("detected mal simulation: loodev too far from generating model")
mal <- T
}
detect_mal <- function(res_df, sim_condition){
mal <- F
# we want to keep reasonable model fit trajectory
# loodev best should not be too far away from data generating model
# loodev 1se not to wide
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = sim_condition$n_ttl_betas, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(4:length(d)) ){
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
print(paste0("sharp decrease in dev at model size ",di))
mal <- T
}
}
# loodev best should not be too far away from data generating model
e <- abs(best_df$best_size[best_df$score=="loodev"] - sim_condition$n_ttl_betas)
if(e >  max(res_df$model_size)/5){
print("detected mal simulation: loodev too far from generating model")
mal <- T
}
# loodev 1se not to wide
e <- best_df$best_size_1se_max[best_df$score=="loodev"] - best_df$best_size_1se_min[best_df$score=="loodev"]
if(e >= 0.9* max(res_df$model_size)){
print("detected mal simulation: loodev 1se too wide")
mal <- T
}
return(mal)
}
pl <- list()
for(i in sort(unique(res_df_iter$iter))){
# res_df <- run_wrapper_lr(sim_condition)
res_df <- res_df_iter %>%
filter(iter==i) %>%
group_by(model_size) %>%
summarise(dev_mean = median(dev),dev_se = sd(dev)/sqrt(max(res_df_iter$iter)),
aic_mean = median(aic),aic_se = sd(aic)/sqrt(max(res_df_iter$iter)),
bic_mean = median(bic),bic_se = sd(bic)/sqrt(max(res_df_iter$iter)),
nic_mean = median(nic),nic_se = sd(nic)/sqrt(max(res_df_iter$iter)),
loopred_mean = median(loopred),loopred_se = sd(loopred)/sqrt(max(res_df_iter$iter)),
loodev_mean = median(loodev),loodev_se = sd(loodev)/sqrt(max(res_df_iter$iter))) %>% as.data.frame()
colnames(res_df) <- gsub("_mean","",colnames(res_df))
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
pl[[i]] <- ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = 5, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
if(detect_mal(res_df, sim_condition)){
print(i)
}
}
ggarrange(plotlist = pl,nrow=2, ncol=5,common.legend = T, legend = "bottom")
# sharp decrease in dev
# d <- c(0,diff(res_df$dev))
# for(di in c(4:length(d)) ){
#   if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
#     print(paste0("sharp decrease in dev at model size ",di))
#     mal <- T
#   }
# }
d <- diff(res_df$dev)
max(d[c( (di-3):(di-1) )])-min(d[c( (di-3):(di-1) )])
abs(d[di])
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
d <- c(0,diff(res_df$dev))
di=20
i
di=21
(max(d[c( (di-3):(di-1) )])-min(d[c( (di-3):(di-1) )]))
sim_condition
c(sim_condition$n_ttl_betas:length(d))
di
max(d[c(im_condition$n_ttl_betas:di)])
max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)])
abs(d[di])
0.5*(max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)]))
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
e1 <- F
e2 <- F
for(di in c(sim_condition$n_ttl_betas:length(d)) ){
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
e1 <- T
}
# if drop in single step is larger than 50% cumulative drop
if(abs(d[di]) > 0.5*(max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)])) ){
e2 <- T
}
if(e1&e2){
print(paste0("sharp decrease in dev at model size ",di))
mal <- T
}
}
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(sim_condition$n_ttl_betas:length(d)) ){
e1 <- F
e2 <- F
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
e1 <- T
}
# if drop in single step is larger than 50% cumulative drop
if(abs(d[di]) > 0.5*(max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)])) ){
e2 <- T
}
if(e1&e2){
print(paste0("sharp decrease in dev at model size ",di))
mal <- T
}
}
detect_mal <- function(res_df, sim_condition){
mal <- F
# we want to keep reasonable model fit trajectory
# loodev best should not be too far away from data generating model
# loodev 1se not to wide
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = sim_condition$n_ttl_betas, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(sim_condition$n_ttl_betas:length(d)) ){
e1 <- F
e2 <- F
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
e1 <- T
}
# if drop in single step is larger than 50% cumulative drop
if(abs(d[di]) > 0.5*(max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)])) ){
e2 <- T
}
if(e1&e2){
print(paste0("sharp decrease in dev at model size ",di))
mal <- T
}
}
# loodev best should not be too far away from data generating model
e <- abs(best_df$best_size[best_df$score=="loodev"] - sim_condition$n_ttl_betas)
if(e >  max(res_df$model_size)/5){
print("detected mal simulation: loodev too far from generating model")
mal <- T
}
# loodev 1se not to wide
e <- best_df$best_size_1se_max[best_df$score=="loodev"] - best_df$best_size_1se_min[best_df$score=="loodev"]
if(e >= 0.9* max(res_df$model_size)){
print("detected mal simulation: loodev 1se too wide")
mal <- T
}
return(mal)
}
pl <- list()
for(i in sort(unique(res_df_iter$iter))){
# res_df <- run_wrapper_lr(sim_condition)
res_df <- res_df_iter %>%
filter(iter==i) %>%
group_by(model_size) %>%
summarise(dev_mean = median(dev),dev_se = sd(dev)/sqrt(max(res_df_iter$iter)),
aic_mean = median(aic),aic_se = sd(aic)/sqrt(max(res_df_iter$iter)),
bic_mean = median(bic),bic_se = sd(bic)/sqrt(max(res_df_iter$iter)),
nic_mean = median(nic),nic_se = sd(nic)/sqrt(max(res_df_iter$iter)),
loopred_mean = median(loopred),loopred_se = sd(loopred)/sqrt(max(res_df_iter$iter)),
loodev_mean = median(loodev),loodev_se = sd(loodev)/sqrt(max(res_df_iter$iter))) %>% as.data.frame()
colnames(res_df) <- gsub("_mean","",colnames(res_df))
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
pl[[i]] <- ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = 5, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
if(detect_mal(res_df, sim_condition)){
print(i)
}
}
detect_mal <- function(res_df, sim_condition){
mal <- F
# we want to keep reasonable model fit trajectory
# loodev best should not be too far away from data generating model
# loodev 1se not to wide
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
# ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
# ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
# ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
#   geom_line() +
#   geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
#   geom_vline(xintercept = sim_condition$n_ttl_betas, color = "grey") +
#   scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
#   theme_minimal() +
#   geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
#   geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
#   labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
#   ylim(ymin, ymax)
# sharp decrease in dev
d <- c(0,diff(res_df$dev))
for(di in c(sim_condition$n_ttl_betas:length(d)) ){
e1 <- F
e2 <- F
if(d[di] < 5*mean(d[c( (di-3):(di-1) )]) & mean(d[c( (di-3):(di-1) )])<(-1) ){
e1 <- T
}
# if drop in single step is larger than 50% cumulative drop
if(abs(d[di]) > 0.5*(max(d[c(sim_condition$n_ttl_betas:di)]) - min(d[c(sim_condition$n_ttl_betas:di)])) ){
e2 <- T
}
if(e1&e2){
print(paste0("sharp decrease in dev at model size ",di))
mal <- T
}
}
# loodev best should not be too far away from data generating model
e <- abs(best_df$best_size[best_df$score=="loodev"] - sim_condition$n_ttl_betas)
if(e > max(res_df$model_size)/2){
print("detected mal simulation: loodev too far from generating model")
mal <- T
}
# loodev 1se not to wide
e <- best_df$best_size_1se_max[best_df$score=="loodev"] - best_df$best_size_1se_min[best_df$score=="loodev"]
if(e >= 0.9* max(res_df$model_size)){
print("detected mal simulation: loodev 1se too wide")
mal <- T
}
return(mal)
}
pl <- list()
for(i in sort(unique(res_df_iter$iter))){
# res_df <- run_wrapper_lr(sim_condition)
res_df <- res_df_iter %>%
filter(iter==i) %>%
group_by(model_size) %>%
summarise(dev_mean = median(dev),dev_se = sd(dev)/sqrt(max(res_df_iter$iter)),
aic_mean = median(aic),aic_se = sd(aic)/sqrt(max(res_df_iter$iter)),
bic_mean = median(bic),bic_se = sd(bic)/sqrt(max(res_df_iter$iter)),
nic_mean = median(nic),nic_se = sd(nic)/sqrt(max(res_df_iter$iter)),
loopred_mean = median(loopred),loopred_se = sd(loopred)/sqrt(max(res_df_iter$iter)),
loodev_mean = median(loodev),loodev_se = sd(loodev)/sqrt(max(res_df_iter$iter))) %>% as.data.frame()
colnames(res_df) <- gsub("_mean","",colnames(res_df))
res_df_long <- res_df %>%
pivot_longer(
cols = c(nic, aic, bic, dev, loodev),  # Specify columns to lengthen
names_to = "score",  # New column for the names
values_to = "value"  # New column for the values
)
best_df <- data.frame()
for(score in c("loodev", "nic", "aic", "bic", "nic")){
best_size <- res_df$model_size[which(res_df[,score]==min(res_df[,score]))][1]
best_score <- res_df[,score][which(res_df[,score]==min(res_df[,score]))][1]
score_1se <- sd(res_df[,score])/sqrt(nrow(res_df))
best_size_1se_min <- min(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_size_1se_max <- max(res_df$model_size[which(abs(res_df[,score]-min(res_df[,score]))<=score_1se)])
best_df <- bind_rows(best_df, data.frame(score,best_size, best_score, score_1se, best_size_1se_min,best_size_1se_max))
}
ymin <- res_df_long$value[which(res_df_long$value == min(res_df_long$value[res_df_long$score=="dev"]) )][1]
ymax <- res_df_long$value[res_df_long$score=="loodev"&res_df_long$model_size==1]
pl[[i]] <- ggplot(res_df_long, aes(x = model_size, y = value, group = score, color = score)) +
geom_line() +
geom_line(data = filter(res_df_long, score == "loodev"), linetype = "dotted") +
geom_vline(xintercept = 5, color = "grey") +
scale_color_manual(values = c("nic" = "red", "aic" = "blue", "bic" = "orange", "dev" = "gray", "loodev" = "black")) +
theme_minimal() +
geom_errorbar(data = best_df, aes(x = best_size, xmin=best_size_1se_min, xmax=best_size_1se_max, y = best_score, color=score))+
geom_point(data = best_df, aes(x = best_size, y = best_score, color=score), size = 3)+
labs(title = paste0("iter = ",i), x = "Model Size", y = "Value", color = "Score") +
ylim(ymin, ymax)
if(detect_mal(res_df, sim_condition)){
print(i)
}
}
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
