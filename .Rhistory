}
test_y <- rms::predictrms(model_obj, newdata = new_data)
write.csv( data.frame(p = 1/(1+exp(-test_y))), paste0(res_dir,"/test_p.csv"),row.names = F)
# Load necessary library
library(ggplot2)
# Generate data
set.seed(123)
n <- 100
x <- runif(n, 0, 10)
noise <- rnorm(n, 0, 2)
y <- 5 + 2 * x - 0.3 * x^2 + noise  # True model with noise
# Create a high-degree polynomial model to induce overfitting
data <- data.frame(x, y)
model_poly <- lm(y ~ poly(x, degree = 10), data = data)  # High-degree polynomial
# Plot the model
ggplot(data, aes(x, y)) +
geom_point() +
stat_smooth(method = "lm", formula = y ~ poly(x, 10), size = 1, se = FALSE, col = "red") +
ggtitle("Overfitting Example with High-Degree Polynomial") +
theme_minimal()
poly(x, 10)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC",
"foreach",
"doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
family = "binomial"
source("./sim_functions.R")
path = paste0("./utils/nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/ass_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/stp_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions_model_selection.R")
#This function runs each condition (i.e. each row in the simulation condition data.frame)
# for test:
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
# saveRDS(res, "./doug_lr_sim_data.RDS")
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC",
"foreach",
"doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
family = "binomial"
source("./sim_functions.R")
path = paste0("./utils/nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/ass_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/stp_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
n_ttl_betas <- c(15) # fixed number of total effects
param_grid <- expand.grid(n_cluster = n_cluster,
n_obs_per_cluster = n_obs_per_cluster,
n_ttl_betas = n_ttl_betas,
fix_rdm_ratio = fix_rdm_ratio,
sigma_fix = sigma_fix,
sigma_rdm_fix_ratio = sigma_rdm_fix_ratio,
ar1_phi = ar1_phi,
na_rate = na_rate)
simulation_conditions <- as.data.frame(param_grid)
simulation_conditions$id <- seq(1:nrow(param_grid))
simulation_conditions$iter <- 100
#This function runs each condition (i.e. each row in the simulation condition data.frame)
# for test:
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
sim_condition
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC",
"foreach",
"doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
family = "binomial"
source("./sim_functions.R")
path = paste0("./utils/nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/ass_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/stp_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
n_ttl_betas <- c(15) # fixed number of total effects
param_grid <- expand.grid(n_cluster = n_cluster,
n_obs_per_cluster = n_obs_per_cluster,
n_ttl_betas = n_ttl_betas,
fix_rdm_ratio = fix_rdm_ratio,
sigma_fix = sigma_fix,
sigma_rdm_fix_ratio = sigma_rdm_fix_ratio,
ar1_phi = ar1_phi,
na_rate = na_rate)
simulation_conditions <- as.data.frame(param_grid)
simulation_conditions$id <- seq(1:nrow(param_grid))
simulation_conditions$iter <- 100
#This function runs each condition (i.e. each row in the simulation condition data.frame)
# for test:
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
# saveRDS(res, "./doug_lr_sim_data.RDS")
sim_condition
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
res$data
# for each of the randome effect predictors add poly 10
poly(res$data$rdm1,2)
res$data$rdm1
res$data[,"rdm1"]
poly(res$data[,"rdm1"],2)
as.matrix(poly(res$data[,rdm],2),nrow=nrow(res$data), ncol=2)
rdm = "rdm1"
as.matrix(poly(res$data[,rdm],2),nrow=nrow(res$data), ncol=2)
over_mat <- as.matrix(poly(res$data[,rdm],2),nrow=nrow(res$data), ncol=2)
paste0(rdm,ncol(over_mat))
paste0(rdm,c(1:ncol(over_mat)))
# for each of the randome effect predictors add poly 2
for(rdm in colnames(res$data)){
over_mat <- as.matrix(poly(res$data[,rdm],2),nrow=nrow(res$data), ncol=2)
colnames(over_mat) <- paste0(rdm,c(1:ncol(over_mat)))
res$data <- cbind(res$data, over_mat)
}
rdm
grep("^rdm\\d+$", colnames(res$data), value = TRUE)
# for each of the randome effect predictors add poly 2
for(rdm in grep("^rdm\\d+$", colnames(res$data), value = TRUE) ){
over_mat <- as.matrix(poly(res$data[,rdm],2),nrow=nrow(res$data), ncol=2)
colnames(over_mat) <- paste0(rdm,c(1:ncol(over_mat)))
res$data <- cbind(res$data, over_mat)
}
res$data
generate_overfit <- function(res, pl = 5){
# for each of the randome effect predictors add poly 2
for(rdm in grep("^rdm\\d+$", colnames(res$data), value = TRUE) ){
over_mat <- as.matrix(poly(res$data[,rdm],pl),nrow=nrow(res$data), ncol=pl)
colnames(over_mat) <- paste0(rdm,c(1:ncol(over_mat)))
res$data <- cbind(res$data, over_mat)
}
return(res)
}
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC",
"foreach",
"doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
family = "binomial"
source("./sim_functions.R")
path = paste0("./utils/nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/ass_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/stp_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
n_ttl_betas <- c(15) # fixed number of total effects
param_grid <- expand.grid(n_cluster = n_cluster,
n_obs_per_cluster = n_obs_per_cluster,
n_ttl_betas = n_ttl_betas,
fix_rdm_ratio = fix_rdm_ratio,
sigma_fix = sigma_fix,
sigma_rdm_fix_ratio = sigma_rdm_fix_ratio,
ar1_phi = ar1_phi,
na_rate = na_rate)
simulation_conditions <- as.data.frame(param_grid)
simulation_conditions$id <- seq(1:nrow(param_grid))
simulation_conditions$iter <- 1
#This function runs each condition (i.e. each row in the simulation condition data.frame)
# for test:
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# add overfit predictors with high order poly
res <- generate_overfit(res)
res
# add overfit predictors with high order poly
res <- generate_overfit(res)
# lr model selection
df <- as.data.frame(res$data)
df$y <- res$y
df$cl <- res$c
fix_vars <- grep("^fix\\d+$", colnames(res$data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(res$data), value = TRUE)
rdm_vars
modified_stepwise_glm_backward <- function(df,
y,
x,
c,
maxstep,
eval_ls,
eval_by,
nfold=10, # default 10 fold cv for "cvpred" and "cvDeviance"
family = c("binomial", "gaussian")[1]
){
res_ls <- list()
tune_ls <- list()
x_remove <- c() # remove one variable per each step
x_picked <- x
if(is.null(maxstep)) maxstep <- length(x)
for(s in rev(seq(1+length(x)-maxstep,length(x)))){
if(s == length(x)){
rmvd_mat <- combn(x_picked, 0) # full model
}else{
rmvd_mat <- combn(x_picked, 1)
}
# ---- find optimal variable at this model size (step) ----
numCores <- detectCores() - 2  # Leave two cores free for system processes
registerDoParallel(cores=numCores)
tune_ls[[length(x)-s+1]] <- foreach(i = c(1:ncol(rmvd_mat)), .packages = c("pROC", "dplyr")) %dopar% {
# define result list object to return
tune_score <- NULL
# ---- train ----
# add "fold" column to original df
x_sub <- setdiff(x_picked, rmvd_mat[,i])
f <- "fold"
fold_idx_df <- data.frame(c=unique(as.character(df[,c])),
fold=cut(seq(1, length(unique(as.character(df[,c])))),
min(length(unique(as.character(df[,c]))),nfold),
labels=c(seq(1, nfold))))
df$c <- df[,c]
df <- merge(df,fold_idx_df,all.x=TRUE)
df <- df[,setdiff(colnames(df), c("c")) ]
df_mdl <- df[complete.cases(df[,c(x_sub,c,f,y)]),c(x_sub,c,f,y)] #dplyr::distinct() # only keep complete rows but must keep duplicates rows for same scale selection
# logistic regression
fml <- paste0(y, "~", paste0(x_sub, collapse = "+"))
mdl <- glm(fml, family = family, data = df_mdl)
mdl$c <- df_mdl[,c]
mdl$x_subset <- x_sub
# ---- eval ----
if(eval_by == "NIC") { tune_score <- NIC(mdl, family=family)$nic }
if(eval_by == "AIC") { tune_score <- NIC(mdl, family=family)$aic }
if(eval_by == "BIC") { tune_score <- BIC(mdl) }
if(eval_by == "Deviance") { tune_score <- NIC(mdl, family=family)$dev }
if(eval_by %in% c("cvpred","cvDeviance") ){
fold_vec <- df_mdl[,f]
}
if(eval_by %in% c("loopred","looDeviance") ){
fold_vec <- df_mdl[,c]
}
if(eval_by %in% c("cvpred","cvDeviance","loopred","looDeviance") ){
# do cv or loo
y_prob <- c()
y_true <- c()
for (f_sub in unique(fold_vec)){
mdl_sub <- glm(fml, family = family, data = df_mdl[!fold_vec==f_sub,])
y_prob <- c(y_prob, predict(mdl_sub, type = "response",
newdata = df_mdl[fold_vec==f_sub,]))
y_true <- c(y_true, df_mdl[fold_vec==f_sub,y])
}
if(eval_by %in% c("cvpred","loopred") ){
if(family=="binomial"){
tune_score <- as.numeric(pROC::auc(pROC::roc(response = y_true, predictor = y_prob))) # AUC
}
if(family=="gaussian"){
tune_score <- sqrt(sum( (y_true-y_prob)^2 )) # MSE
}
}
if(eval_by %in% c("cvDeviance","looDeviance") ){
if(family=="binomial"){
tune_score <- -2*sum(y_true * log(y_prob) + (1 - y_true) * log(1 - y_prob), na.rm = TRUE)
}
if(family=="gaussian"){
s <- sigma(mdl)
tune_score <- length(y_true)*log(2*pi*s^2) + 1/s^2*sum( (y_true-y_prob)^2 )
}
}
}
return(list("tune_score" = tune_score,
"x_removed" = rmvd_mat[,i])) # x_pick means x picked to remove
}
# ---- find optimal variable at this model size (step) ----
tune_vec <- unlist(lapply(tune_ls[[length(x)-s+1]], function(e){return(e$tune_score)}))
x_removed_vec <- unlist(lapply(tune_ls[[length(x)-s+1]], function(e){return(e$x_removed)}))
if(is.null(x_removed_vec)) x_removed_vec <- "All"
if(eval_by %in% c("cvpred","loopred") ) tune_vec <- -tune_vec
x_removed <- x_removed_vec[which(tune_vec==min(tune_vec))]
at_score <- unlist(lapply(tune_ls[[length(x)-s+1]], function(e){return(e$tune_score)}))[which(tune_vec==min(tune_vec))]
# ---- calculate other matrices with current setting ----
x_picked <- setdiff(x_picked, x_removed)
x_remove <- c(x_remove, x_removed)
res_ls[[length(x)-s+1]] <- all_subset_glm(df, y, x_picked, c,
size=length(x_picked),
eval_ls=eval_ls,
family = family)
res_ls[[length(x)-s+1]][['x_removed']] <- x_removed
res_ls[[length(x)-s+1]][['at_score']] <- at_score
}
return(list("res_ls" = res_ls,
"tune_ls" = tune_ls))
}
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC",
"foreach",
"doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
family = "binomial"
source("./sim_functions.R")
path = paste0("./utils/nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/ass_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
path = paste0("./utils/stp_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
n_ttl_betas <- c(15) # fixed number of total effects
param_grid <- expand.grid(n_cluster = n_cluster,
n_obs_per_cluster = n_obs_per_cluster,
n_ttl_betas = n_ttl_betas,
fix_rdm_ratio = fix_rdm_ratio,
sigma_fix = sigma_fix,
sigma_rdm_fix_ratio = sigma_rdm_fix_ratio,
ar1_phi = ar1_phi,
na_rate = na_rate)
simulation_conditions <- as.data.frame(param_grid)
simulation_conditions$id <- seq(1:nrow(param_grid))
simulation_conditions$iter <- 1
#This function runs each condition (i.e. each row in the simulation condition data.frame)
# for test:
sim_condition = simulation_conditions[which(simulation_conditions$id==1),]
# saveRDS(res, "./doug_lr_sim_data.RDS")
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# add overfit predictors with high order poly
res <- generate_overfit(res)
# lr model selection
df <- as.data.frame(res$data)
df$y <- res$y
df$cl <- res$c
fix_vars <- grep("^fix\\d+$", colnames(res$data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(res$data), value = TRUE)
# step-wise forward
m1_sl <- modified_stepwise_glm(df = df,
y = "y",
x = c(fix_vars, rdm_vars),
c = "cl",
maxstep = 25,
eval_ls=c("Deviance", "AIC", "BIC", "NIC", "looDeviance"),
eval_by="looDeviance",
family = family,
forward = T)
source("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/utils/stp_utils/func_modified_stepwise_glm.R")
# step-wise forward
m1_sl <- modified_stepwise_glm(df = df,
y = "y",
x = c(fix_vars, rdm_vars),
c = "cl",
maxstep = 25,
eval_ls=c("Deviance", "AIC", "BIC", "NIC", "looDeviance"),
eval_by="looDeviance",
family = family,
forward = T)
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# add overfit predictors with high order poly
res <- generate_overfit(res)
# lr model selection
df <- as.data.frame(res$data)
df$y <- res$y
df$cl <- res$c
fix_vars <- grep("^fix\\d+$", colnames(res$data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(res$data), value = TRUE)
# step-wise forward
m1_sl <- modified_stepwise_glm(df = df,
y = "y",
x = c(fix_vars, rdm_vars),
c = "cl",
maxstep = 25,
eval_ls=c("Deviance", "AIC", "BIC", "NIC", "looDeviance"),
eval_by="looDeviance",
family = family,
forward = T)
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/utils/stp_utils/func_modified_stepwise_glm.R")
# step-wise forward
m1_sl <- modified_stepwise_glm(df = df,
y = "y",
x = c(fix_vars, rdm_vars),
c = "cl",
maxstep = 25,
eval_ls=c("Deviance", "AIC", "BIC", "NIC", "looDeviance"),
eval_by="looDeviance",
family = family,
forward = T)
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# add overfit predictors with high order poly
res <- generate_overfit(res)
# lr model selection
df <- as.data.frame(res$data)
df$y <- res$y
df$cl <- res$c
fix_vars <- grep("^fix\\d+$", colnames(res$data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(res$data), value = TRUE)
# step-wise forward
m1_sl <- modified_stepwise_glm(df = df,
y = "y",
x = c(fix_vars, rdm_vars),
c = "cl",
maxstep = 25,
eval_ls=c("Deviance", "AIC", "BIC", "NIC", "looDeviance"),
eval_by="looDeviance",
family = family,
forward = T)
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/utils/stp_utils/func_modified_stepwise_glm.R")
