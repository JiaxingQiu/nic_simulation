}
looDeviance
nic
bic
mdl
aic
nic
bic
looDeviance
deviance
sqrt(57600)
# loo auc and loo deviance
y_pred <- c()
y_true <- c()
looDeviance <- c()
for (f_sub in unique(df_mdl$c)){
mdl_sub <- glm(fml, family = family, data = df_mdl[!df_mdl$c==f_sub,])
y_pred_sub <- predict(mdl_sub, type = "response", newdata = df_mdl[df_mdl$c==f_sub,])
y_true_sub <- df_mdl[df_mdl$c==f_sub,"y"]
y_pred <- c(y_pred, y_pred_sub)
y_true <- c(y_true, y_true_sub)
if(family=="gaussian"){
b <- coef(mdl_sub)[!is.na(coef(mdl_sub))]
x <- as.matrix(model.matrix(mdl_sub))[,names(b)]
y <- mdl_sub$y
c <- mdl_sub$c
p <- x%*%b
# nobs <- length(y) #sqrt(1/nobs * sum( (y-p)^2 )) # sub sigma
s <- sigma(mdl_sub)
# s <- sqrt(1/length(y_true_sub) * sum( (y_true_sub-y_pred_sub)^2 )) # sub sigma
looDeviance_sub <- length(y_true_sub)*log(2*pi*s^2) + 1/s^2*sum( (y_true_sub-y_pred_sub)^2 )
looDeviance <- c(looDeviance, looDeviance_sub)
}
}
looDeviance
sum(looDeviance)
nic
aic
bic
deviance
sim_condition
View(simulation_conditions)
sim_condition = simulation_conditions[which(simulation_conditions$id==400),]
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
y = res$y
c = res$c
data = res$data
family = "gaussian"
df_mdl <- as.data.frame(data)
df_mdl$y <- y
df_mdl$c <- as.factor(c)
fix_vars <- grep("^fix\\d+$", colnames(data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(data), value = TRUE)
fml <- formula(paste0("y~", paste0(c(fix_vars, rdm_vars),collapse = "+")))
mdl <- glm(fml, data = df_mdl, family = family)
mdl$c <- c
# information criteria
nic_res <- NIC(mdl, family = family)
deviance <- nic_res$dev
nic <- nic_res$nic
aic <- nic_res$aic
bic <- BIC(mdl)
vcov <- nic_res$robcov
nic
aic
bic
# loo auc and loo deviance
y_pred <- c()
y_true <- c()
looDeviance <- c()
for (f_sub in unique(df_mdl$c)){
mdl_sub <- glm(fml, family = family, data = df_mdl[!df_mdl$c==f_sub,])
y_pred_sub <- predict(mdl_sub, type = "response", newdata = df_mdl[df_mdl$c==f_sub,])
y_true_sub <- df_mdl[df_mdl$c==f_sub,"y"]
y_pred <- c(y_pred, y_pred_sub)
y_true <- c(y_true, y_true_sub)
if(family=="gaussian"){
b <- coef(mdl_sub)[!is.na(coef(mdl_sub))]
x <- as.matrix(model.matrix(mdl_sub))[,names(b)]
y <- mdl_sub$y
c <- mdl_sub$c
p <- x%*%b
# nobs <- length(y) #sqrt(1/nobs * sum( (y-p)^2 )) # sub sigma
s <- sigma(mdl_sub)
# s <- sqrt(1/length(y_true_sub) * sum( (y_true_sub-y_pred_sub)^2 )) # sub sigma
looDeviance_sub <- length(y_true_sub)*log(2*pi*s^2) + 1/s^2*sum( (y_true_sub-y_pred_sub)^2 )
looDeviance <- c(looDeviance, looDeviance_sub)
}
}
if(family=="binomial"){
looAUC <- as.numeric(pROC::auc(pROC::roc(response = y_true, predictor = y_pred)))
looDeviance <- -2*sum(y_true * log(y_prob) + (1 - y_true) * log(1 - y_prob), na.rm = TRUE)
}
if(family=="gaussian"){
looAUC <- NULL
looDeviance <- sum(looDeviance)
}
looDeviance
nic_res
list("mdl"=mdl,
"aic"=aic,
"nic"=nic,
"bic"=bic,
"deviance"= deviance,
"looAUC" = looAUC,
"looDeviance" = looDeviance,
"vcov" = vcov)
sandwich::vcovCL(mdl, cluster = mdl$c)
vcov
deviance
2*cdof
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy_lm.R")
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
source("./sim_functions.R")
path = paste0("./nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
sim_condition = simulation_conditions[which(simulation_conditions$id==400),]
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
cdof
dof
deviance
sum(diag(K%*%solve(J)))
solve(J)
sum(diag(K%*%solve(J)))
2*dof
sum(diag(sandwich::vcovHC(mdl, type = "HC")))
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
y = res$y
c = res$c
data = res$data
family = "gaussian"
df_mdl <- as.data.frame(data)
df_mdl$y <- y
df_mdl$c <- as.factor(c)
fix_vars <- grep("^fix\\d+$", colnames(data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(data), value = TRUE)
fml <- formula(paste0("y~", paste0(c(fix_vars, rdm_vars),collapse = "+")))
mdl <- glm(fml, data = df_mdl, family = family)
mdl$c <- c
b <- coef(mdl)[!is.na(coef(mdl))]
x <- as.matrix(model.matrix(mdl))[,names(b)]
y <- mdl$y
c <- mdl$c
# setup, error checking
# check dim
x <- as.matrix(x) # "x must be a n*p matrix"
nobs <- as.integer(dim(x)[1]) # number of observations
nvar <- as.integer(dim(x)[2]) # number of coefficients
if(length(y) != nobs) stop("x and y have different number of rows")
y <- matrix(y, nrow = nobs)
if(dim(y)[1]!=nobs|dim(y)[2]!=1) stop("y must be a n*1 matrix")
if(length(c) != nobs) stop("x and c have different number of rows")
c <- matrix(c, nrow = nobs)
if(dim(c)[1]!=nobs|dim(c)[2]!=1) stop("c must be a n*1 matrix")
if(length(b) != nvar) stop("x and b have different number of columns")
b <- matrix(b, nrow = nvar)
if(dim(b)[1]!=nvar|dim(b)[2]!=1) stop("b must be a p*1 matrix")
# predicted response
p <- x%*%b
# sigma estimation
s <- sqrt(1/nobs * sum( (y-p)^2 )) # check with sigma(mdl)
# calculate information matrix J [p*p] (Hessian matrix)
J <- -(1/s^2) * t(x) %*% x
# MLE Deviance = -2 * log likelihood
deviance <- nobs*log(2*pi*s^2) + 1/s^2*sum( (y-p)^2 )  # check with AIC(mdl)
# -------------------- unclustered ------------------------
# the gradient of log likelihood per observation per variable i
gi <- x
for(i in 1:dim(x)[2]) gi[,i] <- 1/s^2 * (y - p)*x[,i]
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi
# Huber Sandwich Estimator matrix without clustering
HScov <- solve(J)%*%K%*%solve(J) # check with sandwich::vcovHC(mdl, type = "HC")
# vcov(mdl) check with sandwich::vcovHC(mdl, type = "const")
# approximation of the number of parameters (effective d.f. of the model (counting intercept terms))
dof <- sum(diag(K%*%solve(J)))
dof
sum(diag(sandwich::vcovHC(mdl, type = "HC")))
sandwich::vcovHC(mdl, type = "HC")
HScov
bread(mdl)
meat(mdl)
K
solve(J)
-(1/s^2) * t(x) %*% x
-(1/s^2) * t(x) %*% x / nobs
# calculate information matrix J [p*p] (Hessian matrix)
J <- -(1/s^2) * t(x) %*% x / nobs
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi / nobs
# calculate information matrix J [p*p] (Hessian matrix)
J <- -(1/s^2) * t(x) %*% x / nobs
# MLE Deviance = -2 * log likelihood
deviance <- nobs*log(2*pi*s^2) + 1/s^2*sum( (y-p)^2 )  # check with AIC(mdl)
# -------------------- unclustered ------------------------
# the gradient of log likelihood per observation per variable i
gi <- x
for(i in 1:dim(x)[2]) gi[,i] <- 1/s^2 * (y - p)*x[,i]
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi / nobs
# Huber Sandwich Estimator matrix without clustering
HScov <- solve(J)%*%K%*%solve(J) # check with sandwich::vcovHC(mdl, type = "HC")
HScov
sandwich::vcovHC(mdl, type = "HC")
sum(diag(K%*%solve(J)))
# calculate information matrix J [p*p] (Hessian matrix)
J <- -(1/s^2) * t(x) %*% x / nobs
# MLE Deviance = -2 * log likelihood
deviance <- nobs*log(2*pi*s^2) + 1/s^2*sum( (y-p)^2 )  # check with AIC(mdl)
# -------------------- unclustered ------------------------
# the gradient of log likelihood per observation per variable i
gi <- x
for(i in 1:dim(x)[2]) gi[,i] <- 1/s^2 * (y - p)*x[,i]
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi / nobs
# Huber Sandwich Estimator matrix without clustering
HScov <- solve(J)%*%K%*%solve(J) # check with sandwich::vcovHC(mdl, type = "HC")
# vcov(mdl) check with sandwich::vcovHC(mdl, type = "const")
# approximation of the number of parameters (effective d.f. of the model (counting intercept terms))
dof <- sum(diag(K%*%solve(J)))
dof
# calculate information matrix J [p*p] (Hessian matrix)
J <- -(1/s^2) * t(x) %*% x
# MLE Deviance = -2 * log likelihood
deviance <- nobs*log(2*pi*s^2) + 1/s^2*sum( (y-p)^2 )  # check with AIC(mdl)
# -------------------- unclustered ------------------------
# the gradient of log likelihood per observation per variable i
gi <- x
for(i in 1:dim(x)[2]) gi[,i] <- 1/s^2 * (y - p)*x[,i]
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi
# Huber Sandwich Estimator matrix without clustering
HScov <- solve(J)%*%K%*%solve(J) # check with sandwich::vcovHC(mdl, type = "HC")
# vcov(mdl) check with sandwich::vcovHC(mdl, type = "const")
# approximation of the number of parameters (effective d.f. of the model (counting intercept terms))
dof <- sum(diag(K%*%solve(J)))
dof
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
source("./sim_functions.R")
path = paste0("./nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
sim_condition = simulation_conditions[which(simulation_conditions$id==400),]
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data)
y = res$y
c = res$c
data = res$data
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy_lm.R")
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data)
# setwd(dirname(rstudioapi::getSourceEditorContext()$path))
rm(list = ls())
library(dplyr)
library(rslurm)
library(Matrix)
library(lme4)
library(MASS)
library(pROC)
list.of.packages <- c("dplyr",
"rslurm",
"MASS",
"lme4",
"Matrix",
"pROC")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, lib = "/sfs/qumulo/qhome/jq2uw/R/goolf/4.3")
source("./sim_functions.R")
path = paste0("./nic_utils")
flst = list.files( path)
sapply(c(paste(path,flst,sep="/")), source, .GlobalEnv)
source("./sim_conditions.R")
sim_condition = simulation_conditions[which(simulation_conditions$id==400),]
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
# ground truth mixed effect model
m0 <- fit_glmer(y = res$y,
c = res$c,
data = res$data)
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data)
m1
y = res$y
c = res$c
data = res$data
, family=c("binomial","gaussian")[1]
df_mdl <- as.data.frame(data)
df_mdl$y <- y
df_mdl$c <- as.factor(c)
fix_vars <- grep("^fix\\d+$", colnames(data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(data), value = TRUE)
fml <- formula(paste0("y~", paste0(c(fix_vars, rdm_vars),collapse = "+")))
mdl <- glm(fml, data = df_mdl, family = family)
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate)
y = res$y
c = res$c
data = res$data
df_mdl <- as.data.frame(data)
df_mdl$y <- y
df_mdl$c <- as.factor(c)
fix_vars <- grep("^fix\\d+$", colnames(data), value = TRUE)
rdm_vars <- grep("^rdm\\d+$", colnames(data), value = TRUE)
fml <- formula(paste0("y~", paste0(c(fix_vars, rdm_vars),collapse = "+")))
mdl <- glm(fml, data = df_mdl, family = family)
family=c("binomial","gaussian")[1]
mdl <- glm(fml, data = df_mdl, family = family)
mdl$c <- c
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy_lm.R")
# information criteria
nic_res <- NIC(mdl, family = family)
b <- coef(mdl)[!is.na(coef(mdl))]
x <- as.matrix(model.matrix(mdl))[,names(b)]
y <- mdl$y
c <- mdl$c
if(family == "binomial") res <- vcov.robust.xy(x, y, b, c)
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy.R")
# information criteria
nic_res <- NIC(mdl, family = family)
cdof
dof
sum(diag(K%*%solve(J)))
K
sum(diag(K))
sum(diag(solve(J)))
res <- generate_data(sim_condition$n_cluster,
sim_condition$n_obs_per_cluster,
sim_condition$n_ttl_betas,
sim_condition$fix_rdm_ratio,
sim_condition$sigma_fix,
sim_condition$sigma_rdm_fix_ratio,
sim_condition$ar1_phi,
sim_condition$na_rate,
family = "gaussian")
# ground truth mixed effect model
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy_lm.R")
# lr model evaluation matrices
m1 <- eval_glm(y = res$y,
c = res$c,
data = res$data,
family = "gaussian")
deviance
J
# calculate information matrix J [p*p] (Hessian matrix)
J <- (1/s^2) * t(x) %*% x
J
# MLE Deviance = -2 * log likelihood
deviance <- nobs*log(2*pi*s^2) + 1/s^2*sum( (y-p)^2 )  # check with AIC(mdl)
# -------------------- unclustered ------------------------
# the gradient of log likelihood per observation per variable i
gi <- x
for(i in 1:dim(x)[2]) gi[,i] <- 1/s^2 * (y - p)*x[,i]
# calculate fisher information matrix K [p*p]
K <- t(gi)%*%gi
# Huber Sandwich Estimator matrix without clustering
HScov <- solve(J)%*%K%*%solve(J) # check with sandwich::vcovHC(mdl, type = "HC")
# approximation of the number of parameters (effective d.f. of the model (counting intercept terms))
dof <- sum(diag(K%*%solve(J)))
dof
# AIC
aic <- deviance + 2*dof # check with AIC(mdl)
aic
debugSource("~/Documents/Documents JoyQiu Work/Research/NIC/nic_simulation/nic_utils/vcov.robust.xy_lm.R")
